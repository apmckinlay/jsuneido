THIS FILE MAY BE DELETED ONCE THE jsdi64 PROJECT IS DONE. IT'S JUST MY
SCRATCH NOTES -- VCS 20140717

================================================================================
                 DIFFERENCES BETWEEN x86 AND amd64
================================================================================

WORD SIZE : 64-bit vs 32-bit

    especially for "pointer", "handle", "gdiobj", and STRUCT*.

PARAMETER PASSING:

    amd64 has specific criteria for the first four parameters because it has a
    fastcall-esque ABI:
    
    1) If any of the first four parameters are FP ("float" or "double"), they
       need to be treated specially.

           AFFECTS: nativecall chosen, TypeList.makeParamsMarshallPlan()

    2) An "non-integral", REGARDLESS OF WHETHER IN FIRST FOUR parameters or not,
       has to go by reference.
       
           **non-integral meaning it does not meet both the following criteria:
           
               sizeof(STRUCT) is a power of 2 --and--
               sizeof(STRUCT) <= 8 bytes

================================================================================
                           SIDE GOALS/NICE-TO-HAVEs
================================================================================

[ ] Proper SEH support
[ ] Remove BasicPointer
[ ] Clean up all warnings: jSuneido
[ ] Clean up all cleanable warnings: jsdi
[ ] Move suneido.language.jsdi -> suneido.jsdi
[ ] DOCS!

================================================================================
                                PLAN OF ATTACK
================================================================================

The large majority of the differences can be handled by the marshalling code,
specifically the code that makes marshall plans and marshallers. This can be
done in an "objected-oriented" fashion by creating refactoring to abstract
classes and implementing the small part of the functionality that is ABI-
specific in concrete subclasses.

Marshaller and MarshallPlan will have to be abstract classes or interfaces.

This is because we want to be able to have abstract methods on all the types
like:

   public class Structure
   {
       abstract void marshallIn(Marshaller marshaller, Object value);
   }
   
   public final class x86_Structure
   {
       void marshallIn(Marshaller marshaller, Object value);
       {
           // Actually do the work.
       }
   }

EXCEPT THE ABOVE IS A BAD EXAMPLE IN ONE SENSE: honestly there's nothing ABI-
specific about marshalling a structure once you have the marshaller and the
plan. So Structure.marshallIn(...) need not be abstract. But the Marshaller,
which is "loaded" with a plan, is ABI-specific.

================================================================================
                                REFACTOR PLANS
================================================================================

Marshaller:
MarshallPlan:

    PHASE 1) Abstract and document. This phase is complete when you can run all
             x86 tests and jSuneido GUI with the refactored marshallers.

    PHASE 2) Move to int[] instead of byte[]. This is both a proof of concept
             for the x64 marshaller and a refactor.
             
          2a) Equivalent changes in C++. This phase is complete when you can
              run all x86 tests and jSuneido GUI using the int[] marshaller.

NOTE: That MarshallPlan is basically platform-agnostic. It's just a set of
      directions! However, we may want to separate the posArray up into tuples
      <x, y> where x is the word position and y is the byte position within the
      word... HOWEVER however, this info is available by doing power-of-two
      divisions on the byte positions ANYWAY! So maybe not.

      The ABSTRACT part of MarshallPlan is its makeMarshaller()!

================================================================================
                                  NEXT STEPS
================================================================================

Users of Marshaller.getData():

    Structure.copyOut()      - passed to Structure's native funcs
             .toBuffer()     - passed to Buffer constructor

    NativeCall.invoke()      - passed to NativeCall's native funcs

Users of MarshallPlan.makeMarshaller()

    Dll.call()               - passed to NativeCall

    Structure.copyOut()      - passed to Structure's native funcs

Users of MarshalPlan.makeUnmarshaller()

    Callback.invoke()        - to unmarshall the input arguments
            .invokeVariableIndirect()

    Structure.fromBuffer()   - to unmarshall the buffer contents

--------------------------------------------------------------------------------

So:

    NativeCall => x86 package, take a MarshallerX86
    Dll        => Abstractify
                      DllX86 => make a MarshallerX86
    Structure  => Abstractify
                      StructureX86 => implement abstract copyOut(), fromBuffer(), toBuffer()
    Callback   => Abstractify
                      CallbackX86
                      NOTE1: The cleanest approach is probably to have the
                             abstract invoke() method take an "Object" reference
                             for the data and have the concretes cast to byte[],
                             int[], long[] as appropriate.
                      NOTE2: Make sure native side is doing callVirtual now.

--------------------------------------------------------------------------------

Users of MarshallPlanBuilder:

    <the whole type tree>

--------------------------------------------------------------------------------

OK, ultimate solution:

    new Factory class : abstract but mainly implemented in jsdi
                      : consolidate TypeFactory, DllFactory
                      : also makes MarshallPlanBuilders

    JSDI              : creates Factory based on Platform using Class.forName(...).newInstance()

--------------------------------------------------------------------------------

NEXT STEPS (Saturday):

    3) So DllX86 should have a "private" marshallPlan getter and Dll should not
       have a MarshallPlan marshallPlan member at all.
       
           ... and DllX86's marshallPlan getter should be typed as
           MarshallPlanX86.

    4) INTERLUDE: Need to abstract away marshall plan building.

    5) Note Callback also has a PUBLIC getMarshallPlan() but it is only called
       by ThunkManager, which also needs to be abstracted.

           ... Callback should not have a getMarshallPlan
           ... CallbackX86 should have one returning MarshallPlanX86

    6) Note Structure also has getMarshallPlan() but it is private, as DllX86's
       should be, and is only used by private binary-interface-type methods.
       So it, too, should be abstracted and pushed down to StructureX86.

    7) TypeList.makeMembersMarshallPlan() and TypeList.makeParamsMarshallPlan()
       are only referred to where you would expect: Dll, Callback, Structure,
       and test. So they can be pushed down to TypeListX86.

           ... This will require Factory.makeTypeList(TypeList.Args).
