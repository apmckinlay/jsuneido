THIS FILE MAY BE DELETED ONCE THE jsdi64 PROJECT IS DONE. IT'S JUST MY
SCRATCH NOTES -- VCS 20140717

================================================================================
                 DIFFERENCES BETWEEN x86 AND amd64
================================================================================

WORD SIZE : 64-bit vs 32-bit

    especially for "pointer", "handle", "gdiobj", and STRUCT*.

PARAMETER PASSING:

    amd64 has specific criteria for the first four parameters because it has a
    fastcall-esque ABI:
    
    1) If any of the first four parameters are FP ("float" or "double"), they
       need to be treated specially.

           AFFECTS: nativecall chosen, TypeList.makeParamsMarshallPlan()

    2) An "non-integral", REGARDLESS OF WHETHER IN FIRST FOUR parameters or not,
       has to go by reference.
       
           **non-integral meaning it does not meet both the following criteria:
           
               sizeof(STRUCT) is a power of 2 --and--
               sizeof(STRUCT) <= 8 bytes

================================================================================
                           SIDE GOALS/NICE-TO-HAVEs
================================================================================

[ ] Proper SEH support
[ ] Remove BasicPointer
[ ] Clean up all warnings: jSuneido
[ ] Clean up all cleanable warnings: jsdi
[X] Move suneido.language.jsdi -> suneido.jsdi
[ ] DOCS!

================================================================================
                                PLAN OF ATTACK
================================================================================

The large majority of the differences can be handled by the marshalling code,
specifically the code that makes marshall plans and marshallers. This can be
done in an "objected-oriented" fashion by creating refactoring to abstract
classes and implementing the small part of the functionality that is ABI-
specific in concrete subclasses.

Marshaller and MarshallPlan will have to be abstract classes or interfaces.

This is because we want to be able to have abstract methods on all the types
like:

   public class Structure
   {
       abstract void marshallIn(Marshaller marshaller, Object value);
   }
   
   public final class x86_Structure
   {
       void marshallIn(Marshaller marshaller, Object value);
       {
           // Actually do the work.
       }
   }

EXCEPT THE ABOVE IS A BAD EXAMPLE IN ONE SENSE: honestly there's nothing ABI-
specific about marshalling a structure once you have the marshaller and the
plan. So Structure.marshallIn(...) need not be abstract. But the Marshaller,
which is "loaded" with a plan, is ABI-specific.

================================================================================
                                REFACTOR PLANS
================================================================================

Marshaller:
MarshallPlan:

    PHASE 1) Abstract and document. This phase is complete when you can run all
             x86 tests and jSuneido GUI with the refactored marshallers.

    PHASE 2) Move to int[] instead of byte[]. This is both a proof of concept
             for the x64 marshaller and a refactor.
             
          2a) Equivalent changes in C++. This phase is complete when you can
              run all x86 tests and jSuneido GUI using the int[] marshaller.

NOTE: That MarshallPlan is basically platform-agnostic. It's just a set of
      directions! However, we may want to separate the posArray up into tuples
      <x, y> where x is the word position and y is the byte position within the
      word... HOWEVER however, this info is available by doing power-of-two
      divisions on the byte positions ANYWAY! So maybe not.

      The ABSTRACT part of MarshallPlan is its makeMarshaller()!

================================================================================
                                  NEXT STEPS
================================================================================

PHASE 2!!


