THIS FILE MAY BE DELETED ONCE THE jsdi64 PROJECT IS DONE. IT'S JUST MY
SCRATCH NOTES -- VCS 20140717

================================================================================
                 DIFFERENCES BETWEEN x86 AND amd64
================================================================================

WORD SIZE : 64-bit vs 32-bit

    especially for "pointer", "handle", "gdiobj", and STRUCT*.

PARAMETER PASSING:

    amd64 has specific criteria for the first four parameters because it has a
    fastcall-esque ABI:
    
    1) If any of the first four parameters are FP ("float" or "double"), they
       need to be treated specially.

           AFFECTS: nativecall chosen, TypeList.makeParamsMarshallPlan()

    2) An "non-integral", REGARDLESS OF WHETHER IN FIRST FOUR parameters or not,
       has to go by reference.
       
           **non-integral meaning it does not meet both the following criteria:
           
               sizeof(STRUCT) is a power of 2 --and--
               sizeof(STRUCT) <= 8 bytes

================================================================================
                           SIDE GOALS/NICE-TO-HAVEs
================================================================================

[ ] Proper SEH support
[X] Remove BasicPointer
[X] Clean up all warnings: jSuneido
[X] Clean up all cleanable warnings: jsdi
[ ] Normalize NDEBUG versus _NDEBUG in C++
[X] Move suneido.language.jsdi -> suneido.jsdi
[ ] DOCS!
[ ] Normalize JSDIException messages

================================================================================
                           HAND-MEETS-FACE MOMENTS
================================================================================

The code would be even simpler (no need to fool around with different
native calls, no need to have a separate callback_x86, etc.) if we just
marshalled EVERYTHING to Java long[].

May need to undo some changes.

    1) marshall_word_t is now always uint64_t ???
    2) Marshalling pointer positions would have to go back to always byte index

    ...?

================================================================================
                       PHASE 3: Java Changes for AMD64
================================================================================

[ ] Proxy -> LateBind
[ ] TypeId.PROXY -> TypeId.LATE_BIND
[ ] + New jsdi.Type.Proxy, acting as actual Proxy
[ ] TypeList: Push question of whether params or not down into the typelist
    itself.
        ( ) private final boolean isParamsList
        ( ) Remove makeParamsMarshallPlan()
        ( ) Remove makeXXXMarshallPlan()
        ( ) Have one single makeMarshallPlan( )
[ ] + New jsdi.abi_amd64.LateBindValueShim
        ( ) Only wrap around <parameter> typelist LateBinds that return
            StorageType.VALUE
        ( ) Marshalling behaviour etc. is: if resolve() => STRUCT, then pass
            by value or reference; if resolve() => ELSE, use underyling.