In May 2014 I tried to implement fastcalls under the naive assumption I could
pass Java longs (int64) for every parameter. This can't possibly work because
you can't cast <TYPE> stdcall (*)(char, int, long, short) to
<TYPE> stdcall (*)(int64, int64, int64, int64), which is what I was naively
trying to do. So this was a failed attempt and I have had to revert it.

The original design intention, which had faded away into my memory, didn't
suffer from this design flaw because it assumed 32-bit integer parameters which
is how __stdcall works on x86. (i.e. If you have a 'char', it still takes up an
'int').

The reason I screwed up the May 2014 attempt is that I wanted to resolve the
latent 64-bit issue. In other words, I wanted an implementation that would
translate with minimal fuss into x64. This requires knowing how parameters
actually get marshalled in Microsoft's x64 calling convention, so that needs to
be figured out before proceeding. Also: do long, int, char, etc. still retain
their size under MSx64 convention?

Also before proceeding, I need to implement the "pointer" primitive and ensure
it gets changed on all the libraries. Then update DllSummarizer to show the
hypothetical 64-bit parameters everything that would be "pointer" is "long" in
the libraries and shows up as 32-bits, which gives a misleading picture of how
fastcalls will NEED to be implemented under x64.



FAILED FASTDLL IMPLEMENTATION OF 20140531
=========================================

NOTE: I think a 'pointer' type call can and should be considered a 'fast' call
      because the "point" of it is the pointer is opaque. Actually, come to
      think of it, maybe a better term for it is "opaque". NO! Andrew doesn't
      like this.

+ Dll
|
+---+ GenericDll
|
+---+ FastDll
    |
    +---+ FastDll0Base
        |
        +--- FastDll0
        |
        +--- FastDll0NoRet
        |
        +---+ FastDll1Base [dllParam0]
            |
            +---+ FastDll2Base [dllParam0, dllParam1]
                |
                +---+ FastDll3Base [dllParam0, dllParam1, dllParam2]
                    |
                    +---+ FastDll4Base [dllParam0, dllParam1, dllParam3]

Array usage => 8 [ref to array] + 12 [array header] + typeSize x numElems

================================================================================
DllBase               extends SuCallable
================================================================================

final long     funcPtr;    // Pointer to the function to invoke on the native side
final TypeList dllParams;  // Needed for documentation etc.
final Type     returnType;

    // Don't need ReturnTypeGroup because it is always INTEGER in the FastDll
    // subclass.

    // Don't store NativeCall here because there's a difference in availability
    // of null-ness.

final String     valueName;
final DllFactory dllFactory;
final String     libraryName;
final String     userFunctionName;
final String     actualFunctionName;

    // These are all needed.
    
    // Don't need to store the MarshallPlan since it can be generated for DLL
    // based on the TypeList dllParams and the Type returnType.

================================================================================
For FastDll, should "extract" parameters as BasicValue from dllParams? Probably
not because it doesn't have to be a BasicValue: really anything that is not a
proxy can be passed by assumption. EXCEPT THAT the way the compiler works,
every parameter type has to be either a proxy or a basicvalue. So now that I
think about it, yes, we should collapse dllParams to an array of BasicValue.

I think we should add a method to BasicValue called marshallIntoLong(...) or
whatever the word we use to mean a JAVA long...
================================================================================


================================================================================
OLD DLL 
================================================================================

	final long            funcPtr;
	final TypeList        dllParams; // not to confuse with SuCallable.params
	final Type            returnType;
	final ReturnTypeGroup returnTypeGroup; // never null
	final NativeCall      nativeCall;      // null if params isn't closed

	final String     valueName;
	final DllFactory dllFactory;
	final String     libraryName;
	final String     userFunctionName;
	final String     actualFunctionName;

	MarshallPlan marshallPlan;

    
================================================================================
HOW TO DO PARAMETERIZED JUNITS
================================================================================

Parameterized Tests: JUnit 4 comes with another special runner: Parameterized,
which allows you to run the same test with different data. For example, in the
following peice of code will imply that the tests will run four times, with the
parameter "number" changed each time to the value in the array.

@RunWith(value = Parameterized.class)
public class StackTest {
 Stack<Integer> stack;
 private int number;

 public StackTest(int number) {
   this.number = number;
 }

 @Parameters
 public static Collection data() {
   Object[][] data = new Object[][] { { 1 }, { 2 }, { 3 }, { 4 } };
   return Arrays.asList(data);
 }
 ...
}
The requirement for parameterized tests is to
Have the annotation @RunWith for the Test Class
Have a public static method that returns a Collection for data. Each element of the collection must be an Array of the various paramters used for the test.
You will also need a public constructor that uses the parameters
